
#include "mesh_file_helper.h"
#include "ply.h"
#include <assert.h>
#include <stdlib.h>


// ----------------------------------------------------------------------------
namespace VR
{
// ----------------------------------------------------------------------------
namespace MeshFileHelper
{
// ============================================================================
// ----------------------------------------------------------------------------
// ============================================================================
static PlyProperty vertProps[] =
{
	{"x", PLY_FLOAT, PLY_FLOAT, offsetof(Vertex,x), 0, 0, 0, 0},
	{"y", PLY_FLOAT, PLY_FLOAT, offsetof(Vertex,y), 0, 0, 0, 0},
	{"z", PLY_FLOAT, PLY_FLOAT, offsetof(Vertex,z), 0, 0, 0, 0},
	{"nx", PLY_FLOAT, PLY_FLOAT, offsetof(Vertex,nx), 0, 0, 0, 0},
	{"ny", PLY_FLOAT, PLY_FLOAT, offsetof(Vertex,ny), 0, 0, 0, 0},
	{"nz", PLY_FLOAT, PLY_FLOAT, offsetof(Vertex,nz), 0, 0, 0, 0},
	{"diffuse_red", PLY_UCHAR, PLY_UCHAR, offsetof(Vertex,r), 0, 0, 0, 0},
	{"diffuse_green", PLY_UCHAR, PLY_UCHAR, offsetof(Vertex,g), 0, 0, 0, 0},
	{"diffuse_blue", PLY_UCHAR, PLY_UCHAR, offsetof(Vertex,b), 0, 0, 0, 0},
};
// ----------------------------------------------------------------------------
static PlyProperty faceProps[] =
{
	{"vertex_indices", PLY_INT, PLY_INT, offsetof(Face,vertices),
		1, PLY_UCHAR, PLY_UCHAR, offsetof(Face,nbVertices)},
};
// ============================================================================
// ----------------------------------------------------------------------------
// ============================================================================
bool LoadMeshFromPlyFile(Mesh& parMesh, char* parFilename)
{
	assert(parFilename);
	assert(parMesh.vertices.size() == 0);
	assert(parMesh.faces.size() == 0);

	// prepare file
	int nelems;
	char** elem_names;
	int file_type;
	float version;
	PlyFile* plyFile = ply_open_for_reading(parFilename, &nelems, &elem_names, &file_type, &version);
	if (!plyFile)
		return false;
	assert(plyFile->file_type == PLY_ASCII);
	assert(plyFile->version == 1.0f);
	assert((plyFile->nelems == 1) || (plyFile->nelems == 2));
	assert(equal_strings(plyFile->elems[0]->name, "vertex"));
	if (plyFile->nelems == 2)
		assert(equal_strings(plyFile->elems[1]->name, "face"));

	// get vertices
	int nbVertices;
	int nbVertexProps;
	ply_get_element_description(plyFile, "vertex", &nbVertices, &nbVertexProps);
	assert(nbVertices > 0);
	assert(nbVertexProps == 3 || nbVertexProps == 9); // pos only or pos/normal/color
	for (int prop = 0; prop < nbVertexProps; ++prop)
		ply_get_property(plyFile, "vertex", &vertProps[prop]);
	for (int vertex = 0; vertex < nbVertices; ++vertex)
	{
		Vertex curVertex;
		ply_get_element(plyFile, (void*) &curVertex);
		if (nbVertexProps == 3)
		{
			curVertex.nx = curVertex.ny = curVertex.nz = 0.f;
			curVertex.r = 255;
			curVertex.g = 0;
			curVertex.b = 0;
		}
		parMesh.vertices.push_back(curVertex);
	}

	// get faces
	if (plyFile->nelems == 2)
	{
		int nbFaces = 0;
		int nbFaceProps = 0;
		ply_get_element_description(plyFile, "face", &nbFaces, &nbFaceProps);
		assert(nbFaces > 0);
		assert(nbFaceProps == 1);

		ply_get_property(plyFile, "face", &faceProps[0]);
		for (int face = 0; face < nbFaces; ++face)
		{
			Face curFace;
			ply_get_element(plyFile, (void*) &curFace);
			assert(curFace.nbVertices == 3); // mesh should contain only triangles
			parMesh.faces.push_back(curFace);
		}
	}

	ply_close(plyFile);

	return true;
}
// ----------------------------------------------------------------------------
bool SaveMeshToPlyFile(const Mesh& parMesh, char* parFilename, bool parOnlyPos)
{
	assert(parFilename);

	// prepare file
	char* elementNames[] = {"vertex", "face"};
	float version;
	PlyFile* plyFile = 0;
	int nbElements = (parMesh.faces.size() > 0) ? 2 : 1;
	plyFile = ply_open_for_writing(parFilename, nbElements, elementNames, PLY_ASCII, &version);
	if (!plyFile)
		return false;
	
	// header
	int nbVertices = parMesh.vertices.size();
	assert(nbVertices > 0);
	ply_element_count(plyFile, "vertex", nbVertices);
	int nbVertProps = parOnlyPos ? 3 : 9;
	for (int prop = 0; prop < nbVertProps; ++prop)
		ply_describe_property(plyFile, "vertex", &vertProps[prop]);
	int nbFaces = parMesh.faces.size();
	if (nbFaces > 0)
	{
		ply_element_count(plyFile, "face", nbFaces);
		ply_describe_property(plyFile, "face", &faceProps[0]);
	}
	ply_put_comment(plyFile, "Generated by the RedCloud team softwares");
	ply_header_complete(plyFile);

	// data
	ply_put_element_setup(plyFile, "vertex");
	for (int vertex = 0; vertex < nbVertices; ++vertex)
		ply_put_element(plyFile, (void*) &parMesh.vertices[vertex]);
	if (nbFaces > 0)
	{
		ply_put_element_setup(plyFile, "face");
		for (int face = 0; face < nbFaces; ++face)
			ply_put_element(plyFile, (void*) &parMesh.faces[face]);
	}

	ply_close(plyFile);

	return true;
}
// ----------------------------------------------------------------------------
void DeepCopyMesh(Mesh& parMeshDst, const Mesh& parMeshSrc)
{
	int nbVertices = parMeshSrc.vertices.size();
	assert(nbVertices > 0);
	for (int curVertex = 0; curVertex < nbVertices; ++curVertex)
		parMeshDst.vertices.push_back(parMeshSrc.vertices[curVertex]);

	int nbFaces = parMeshSrc.faces.size();
	for (int curFace = 0; curFace < nbFaces; ++curFace)
	{
		const Face& srcFace = parMeshSrc.faces[curFace];
		assert(srcFace.nbVertices == 3); // only triangles

		Face dstFace;
		dstFace.nbVertices = 3;
		dstFace.vertices = (int*) malloc(sizeof(int) * 3);
		assert(dstFace.vertices);
		dstFace.vertices[0] = srcFace.vertices[0];
		dstFace.vertices[1] = srcFace.vertices[1];
		dstFace.vertices[2] = srcFace.vertices[2];

		parMeshDst.faces.push_back(dstFace);
	}
}
// ============================================================================
// ----------------------------------------------------------------------------
// ============================================================================
}
// ----------------------------------------------------------------------------
}
// ----------------------------------------------------------------------------
